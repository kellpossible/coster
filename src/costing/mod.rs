//! This module holds the business logic for the `coster` application.
//!
//! What do we want this to do?
//!
//! 1. Create a new Tab (a list of expenses and their associated users)

use crate::accounting::{
    sum_account_states, Account, AccountID, AccountState, AccountStatus, AccountingError, Action,
    Program, ProgramState, Transaction, TransactionElement,
};
use crate::currency::{Commodity, Currency, CurrencyCode, CurrencyError};
use crate::exchange_rate::ExchangeRate;
use chrono::{DateTime, Local, NaiveDate, Utc};
use std::collections::HashMap;
use std::{convert::TryInto, rc::Rc};
use thiserror::Error;

#[derive(Error, Debug)]
pub enum CostingError {
    #[error("error relating to accounting")]
    Accounting(#[from] AccountingError),
    #[error("error relating to currencies")]
    Currency(#[from] CurrencyError),
}

#[derive(Debug)]
pub struct User {
    pub id: String,
    pub name: String,
    pub email: Option<String>,
    pub account: Rc<Account>,
}

impl User {
    pub fn new(id: &str, name: &str, email: Option<&str>, currency: Rc<Currency>) -> User {
        User {
            id: String::from(id),
            name: String::from(name),
            email: email.map(|e| String::from(e)),
            account: Rc::from(Account::new(Some(id), currency, None)),
        }
    }
}

impl PartialEq for User {
    fn eq(&self, other: &User) -> bool {
        self.id == other.id
    }
}

struct Costing {
    pub users: Vec<Rc<User>>,
    pub expenses: Vec<Expense>,
    pub working_currency: CurrencyCode,
}

/// Calculate the differences in amounts between two sets of account
/// states, per account.
fn account_state_difference(
    account_states_from: &HashMap<AccountID, AccountState>,
    account_states_to: &HashMap<AccountID, AccountState>,
) -> Result<HashMap<AccountID, AccountState>, CostingError> {
    assert!(account_states_from.len() == account_states_to.len());

    let mut result: HashMap<AccountID, AccountState> = HashMap::new();

    for (from_id, from_state) in account_states_from {
        let to_state = match account_states_to.get(from_id) {
            Some(state) => state,
            None => {
                return Err(CostingError::Accounting(
                    AccountingError::MissingAccountState(from_id.clone()),
                ))
            }
        };

        let difference_amount = to_state
            .amount
            .subtract(&from_state.amount)
            .map_err(|e| AccountingError::Currency(e))?;

        let difference_state = AccountState::new(
            to_state.account.clone(),
            difference_amount,
            AccountStatus::Open,
        );

        result.insert(from_id.clone(), difference_state);
    }

    Ok(result)
}

impl Costing {
    /// Produce a set of transactions, that, when applied to the
    /// result of the actual transactions generated by this Costing's
    /// expenses, will ensure that each user has fairly shared each
    /// expense that they have participated in.
    ///
    /// The aim here, is to produce a minimal set of transactions.
    fn balance_transactions(&self) -> Result<Vec<Transaction>, CostingError> {
        let mut actual_transactions: Vec<Box<dyn Action>> = Vec::new();
        let mut shared_transactions: Vec<Box<dyn Action>> = Vec::new();

        for expense in &self.expenses {
            actual_transactions
                .push(Box::from(expense.get_actual_transaction()) as Box<dyn Action>);
            shared_transactions
                .push(Box::from(expense.get_shared_transaction()) as Box<dyn Action>);
        }

        let actual_program = Program::new(actual_transactions);

        let accounts: Vec<Rc<Account>> = self.users.iter().map(|u| u.account.clone()).collect();
        let mut actual_program_state = ProgramState::new(accounts.clone());

        actual_program_state
            .execute_program(&actual_program)
            .unwrap();

        // the shared_program_state (after execution) is the desired
        // end-state where all users have fairly shared the expenses
        // that they have participated in.
        let shared_program = Program::new(shared_transactions);
        let mut shared_program_state = ProgramState::new(accounts);
        shared_program_state
            .execute_program(&shared_program)
            .unwrap();

        let account_states_from = &actual_program_state.account_states;
        let account_states_to = &shared_program_state.account_states;

        let account_differences = account_state_difference(account_states_from, account_states_to)?;

        let from_sum = sum_account_states(account_states_from, self.working_currency, None);
        dbg!(from_sum);
        let to_sum = sum_account_states(account_states_to, self.working_currency, None);
        dbg!(to_sum);
        let differences_sum = sum_account_states(&account_differences, self.working_currency, None);
        dbg!(differences_sum);

        // for each user
        // if the account differences are large

        //

        Ok(Vec::new())
    }
}

struct UserAction<T> {
    data: Rc<T>,
    datetime: DateTime<Utc>,
    user: Rc<User>,
}

struct Ownership<T> {
    user: Rc<User>,
    data: T,
}

struct Tab {
    pub working_currency: Option<Rc<Currency>>,
    pub users: Vec<Rc<User>>,
    pub expenses: Vec<Expense>,
}

pub struct Expense {
    /// The description of this expense
    pub description: String,
    /// The account that this expense will be attributed to
    pub account: Rc<Account>,
    /// The date that this expense was incurred
    pub date: NaiveDate,
    /// The [User](User) who paid this expense
    pub paid_by: Rc<User>,
    /// [User](User)s who were involved in/benefited from/are sharing this expense
    pub shared_by: Vec<Rc<User>>,
    /// The amount of money
    pub amount: Commodity,
    /// The exchange rate to use for converting the expense to the working currency
    pub exchange_rate: Option<ExchangeRate>,
}

impl Expense {
    /// Create a new expense
    ///
    /// # Example
    /// ```
    /// # use coster::costing::{Expense, User};
    /// use coster::accounting::{Transaction, Account};
    /// use coster::currency::{Commodity, Currency};
    /// use std::rc::Rc;
    /// use chrono::NaiveDate;
    ///
    /// let aud = Rc::from(Currency::from_alpha3("AUD").unwrap());
    /// let user1 = Rc::from(User::new("user1", "User 1", None, aud.clone()));
    /// let user2 = Rc::from(User::new("user2", "User 2", None, aud.clone()));
    ///
    /// let expenses_account = Rc::from(Account::new(Some("Expenses"), aud.clone(), None));
    ///
    /// let expense = Expense::new(
    ///    "some expense", expenses_account.clone(),
    ///    NaiveDate::from_ymd(2020, 2, 27),
    ///    user1.clone(),
    ///    vec![user1.clone(), user2.clone()],
    ///    Commodity::from_str("300.0 AUD").unwrap(),
    ///    None
    /// );
    ///
    /// assert_eq!(expense.account, expenses_account);
    /// assert_eq!(NaiveDate::from_ymd(2020, 2, 27), expense.date);
    /// assert_eq!(user1.clone(), expense.paid_by);
    /// assert_eq!(vec![user1.clone(), user2.clone()], expense.shared_by);
    /// assert_eq!(Commodity::from_str("300.0 AUD").unwrap(), expense.amount);
    /// ```
    pub fn new(
        description: &str,
        account: Rc<Account>,
        date: NaiveDate,
        paid_by: Rc<User>,
        shared_by: Vec<Rc<User>>,
        amount: Commodity,
        exchange_rate: Option<ExchangeRate>,
    ) -> Expense {
        Expense {
            description: String::from(description),
            account,
            date,
            paid_by,
            shared_by,
            amount,
            exchange_rate,
        }
    }

    /// Get the transaction that occurred initially, where the user `paid_by`
    /// paid for the expense.
    ///
    /// # Example
    /// ```
    /// # use coster::costing::{Expense, User};
    /// use coster::accounting::{Transaction, Account};
    /// use coster::currency::{Commodity, Currency};
    /// use std::rc::Rc;
    /// use chrono::NaiveDate;
    ///
    /// let aud = Rc::from(Currency::from_alpha3("AUD").unwrap());
    /// let user1 = Rc::from(User::new("user1", "User 1", None, aud.clone()));
    /// let user2 = Rc::from(User::new("user2", "User 2", None, aud.clone()));
    /// let user3 = Rc::from(User::new("user3", "User 3", None, aud.clone()));
    ///
    /// let expenses_account = Rc::from(Account::new(Some("Expenses"), aud.clone(), None));
    ///
    /// let expense = Expense::new(
    ///    "some expense", expenses_account.clone(),
    ///    NaiveDate::from_ymd(2020, 2, 27),
    ///    user1.clone(),
    ///    vec!(user1.clone(), user2.clone(), user3.clone()),
    ///    Commodity::from_str("300.0 AUD").unwrap(),
    ///    None
    /// );
    ///
    /// let actual_transaction = expense.get_actual_transaction();
    ///
    /// assert_eq!(2, actual_transaction.elements.len());
    /// let user1_element = actual_transaction.get_element(&user1.account).unwrap();
    /// assert_eq!(Some(Commodity::from_str("-300.0 AUD").unwrap()), user1_element.amount);
    /// let expense_element = actual_transaction.get_element(&expenses_account).unwrap();
    /// assert_eq!(None, expense_element.amount);
    /// ```
    pub fn get_actual_transaction(&self) -> Transaction {
        Transaction::new(
            Some(self.description.clone()),
            self.date,
            vec![
                TransactionElement::new(
                    self.paid_by.account.clone(),
                    Some(self.amount.negate()),
                    self.exchange_rate.clone(),
                ),
                TransactionElement::new(self.account.clone(), None, self.exchange_rate.clone()),
            ],
        )
    }

    /// Get a transaction where this expense is shared by all the users involved
    ///
    /// # Example
    /// ```
    /// # use coster::costing::{Expense, User};
    /// use coster::accounting::{Transaction, Account};
    /// use coster::currency::{Commodity, Currency};
    /// use std::rc::Rc;
    /// use chrono::NaiveDate;
    ///
    /// let aud = Rc::from(Currency::from_alpha3("AUD").unwrap());
    /// let user1 = Rc::from(User::new("user1", "User 1", None, aud.clone()));
    /// let user2 = Rc::from(User::new("user2", "User 2", None, aud.clone()));
    /// let user3 = Rc::from(User::new("user3", "User 3", None, aud.clone()));
    ///
    /// let expenses_account = Rc::from(Account::new(Some("Expenses"), aud.clone(), None));
    ///
    /// let expense = Expense::new(
    ///    "some expense", expenses_account.clone(),
    ///    NaiveDate::from_ymd(2020, 2, 27),
    ///    user1.clone(),
    ///    vec!(user2.clone(), user3.clone()),
    ///    Commodity::from_str("300.0 AUD").unwrap(),
    ///    None
    /// );
    ///
    /// let shared_transaction = expense.get_shared_transaction();
    ///
    /// assert_eq!(3, shared_transaction.elements.len());
    /// assert!(shared_transaction.get_element(&user1.account).is_none());
    ///
    /// let user2_element = shared_transaction.get_element(&user2.account).unwrap();
    /// let user3_element = shared_transaction.get_element(&user3.account).unwrap();
    /// assert_eq!(Some(Commodity::from_str("-150.0 AUD").unwrap()), user2_element.amount);
    /// assert_eq!(Some(Commodity::from_str("-150.0 AUD").unwrap()), user3_element.amount);
    ///
    /// let expense_element = shared_transaction.get_element(&expenses_account).unwrap();
    /// assert_eq!(None, expense_element.amount);
    /// ```
    pub fn get_shared_transaction(&self) -> Transaction {
        let mut elements: Vec<TransactionElement> = Vec::new();

        // TODO: perhaps consider using divide_share instead
        let divided = self
            .amount
            .divide(self.shared_by.len().try_into().unwrap())
            .negate();

        for user in &self.shared_by {
            let element = TransactionElement::new(
                user.account.clone(),
                Some(divided),
                self.exchange_rate.clone(),
            );
            elements.push(element);
        }

        elements.push(TransactionElement::new(
            self.account.clone(),
            None,
            self.exchange_rate.clone(),
        ));

        Transaction::new(
            Some(self.description.clone()),
            Local::today().naive_local(),
            elements,
        )
    }
}

mod tests {
    use super::{Expense, User};
    use crate::accounting::{Account, Transaction};
    use crate::currency::{Commodity, Currency};
    use chrono::NaiveDate;
    use std::rc::Rc;

    #[test]
    fn balance() {
        let aud = Rc::from(Currency::from_alpha3("AUD").unwrap());

        let user1 = Rc::from(User::new("user1", "User 1", None, aud.clone()));
        let user2 = Rc::from(User::new("user2", "User 2", None, aud.clone()));
        let user3 = Rc::from(User::new("user3", "User 3", None, aud.clone()));

        let expenses_account = Rc::from(Account::new(Some("Expenses"), aud.clone(), None));

        let expense = Expense::new(
            "some expense",
            expenses_account.clone(),
            NaiveDate::from_ymd(2020, 2, 27),
            user1.clone(),
            vec![user2.clone(), user3.clone()],
            Commodity::from_str("300.0 AUD").unwrap(),
            None,
        );
    }
}
